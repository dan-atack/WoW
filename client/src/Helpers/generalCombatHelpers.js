// When either the player's attack throws a baddie, or the baddie's attack throws the player,
// find out if there's an obstacle in the path to the destination and return the closest possible coords:
export const determineObstacle = (distance, direction, attackerCoords, victimCoords, seed) => {
  // console.log(`distance: ${distance}, ${typeof distance}`);
  // console.log(`direction: ${direction}, ${typeof direction}`);
  // console.log(`attacker coords: ${attackerCoords.x}, ${attackerCoords.y}`);
  // console.log(`victim coords: ${victimCoords.x}, ${victimCoords.y}`);
  // Return the location the victim is currently standing in if there is no distance to be thrown:
  if (distance === 0) return victimCoords;
  // For each cardinal direction, make a list of all the squares the victim will cross to travel the distance, in that direction:
  let potentialPositions = [];
  switch (direction) {
    case 'east':
      for (let i = 1; i <= distance; i++) {
        // Only add positions inside the map's boundaries to the PP list:
        if (victimCoords.x + i <= seed.width) {
          potentialPositions.push({
            x: victimCoords.x + i,
            y: victimCoords.y
          })
        }
      }
      break;
    case 'west':
      for (let i = 1; i <= distance; i++) {
        if (victimCoords.x - i > 0) {
          potentialPositions.push({
            x: victimCoords.x - i,
            y: victimCoords.y
          })
        }
      }
      break;
    case 'south':
      for (let i = 1; i <= distance; i++) {
        if (victimCoords.y + i <= seed.height) {
          potentialPositions.push({
            x: victimCoords.x,
            y: victimCoords.y + i
          })
        }
      }
      break;
    case 'north':
      for (let i = 1; i <= distance; i++) {
        if (victimCoords.y - i > 0) {
          potentialPositions.push({
            x: victimCoords.x,
            y: victimCoords.y - i
          })
        }
      }
    default:
      // If the direction given doesn't match, return original coords and display a message (this is an exception):
      if (potentialPositions.length === 0 && distance > 0) {
        // console.log(`Unexpected value given for attack throw direction: ${direction}`);
        return victimCoords;
      }
  }
  // console.log(potentialPositions);
  // If no valid positions have been generated by this point, the victim is at the edge of the map. Return original coords:
  if (potentialPositions.length === 0) {
    // console.log('No valid found for attack throw destination. Returning original coordinates.');
    return victimCoords;
  }
  // Ensure the attacker's own location is not among the potential destinations to prevent rendering errors:
  potentialPositions = potentialPositions.filter(position => !(position.x === attackerCoords.x && position.y === attackerCoords.y));
  // console.log(potentialPositions);
  // Next, find which obstacles are potentially in the way of the attack's throw, based on the target's original position:
  let possibleObstacles = [];
  switch (direction) {
    case 'east':
      // Look at all of the obstacles that are to your East (right), then see if you hit any of them:
      possibleObstacles = seed.obstructions.filter((obstacle) => obstacle.x > victimCoords.x);
      // Loop through the potential positions array to see if any of those spaces is obstructed:
      for (const position of potentialPositions) {
        for (const obstacle of possibleObstacles) {
          if (position.x === obstacle.x && position.y === obstacle.y) {
            return { x: position.x - 1, y: victimCoords.y };
          }
        }
      }
      break;
    case 'west':
      possibleObstacles = seed.obstructions.filter((obstacle) => obstacle.x < victimCoords.x);
      for (const position of potentialPositions) {
        for (const obstacle of possibleObstacles) {
          if (position.x === obstacle.x && position.y === obstacle.y) {
            return { x: position.x + 1, y: victimCoords.y };
          }
        }
      }
      break;
    case 'south':
      possibleObstacles = seed.obstructions.filter((obstacle) => obstacle.y > victimCoords.y);
      // Analogue of east case, except that now we get all of the y values that are greater (further south) than you:
      for (const position of potentialPositions) {
        for (const obstacle of possibleObstacles) {
          if (position.x === obstacle.x && position.y === obstacle.y) {
            return { x: victimCoords.x, y: position.y - 1 };
          }
        }
      }
      break;
    case 'north':
      possibleObstacles = seed.obstructions.filter((obstacle) => obstacle.y < victimCoords.y);
      for (const position of potentialPositions) {
        for (const obstacle of possibleObstacles) {
          if (position.x === obstacle.x && position.y === obstacle.y) {
            return { x: victimCoords.x, y: position.y + 1 };
          }
        }
      }
      break;
    default:
      // Default should only occur in the event of some kind of failure in the execution of one of the above cases.
      return victimCoords;
  }
  // If no obstacle is detected, return the farthest destination OR the original coords if there are no potential positions:
  return potentialPositions[potentialPositions.length - 1] || victimCoords;
}

// This is an experimental helper function that will set a one-time timeout that delays the advance to the next combat phase.
// Time = number of milliseconds delay; nextPhase = string name of a combat phase; setNextPhase = dispatcher, passed as a function.
export const advanceCombatSequence = (time, nextPhase, setNextPhase) => {
  // console.log(`Initiating ${time / 1000} second countdown to next phase: ${nextPhase}`);
  setTimeout(() => {
    setNextPhase(nextPhase);
  }, time);
}

// This function implements a one-time timeout to delay between the start of a MOVEMENT or ATTACK combat phase and its outcome (e.g. between when you click on a tile or hit the baddie, or he moves/hits you, and when the character's sprite actually arrives there).
// PROPS: time = delay in milliseconds, nextPhase = string name of combat phase OR NULL (in the case that a phase advance is actually NOT required, such as the first hit in a queue of attacks), dispatch = literally the redux dispatcher (ew), setNextPhase = REDUX setPhase action, setPosition = RECOIL position setter for either the player or the baddie, and coords = {x:number, y:number}
export const advanceCombatWithMovement = async (time, nextPhase, setNextPhase, setPosition, coords) => {
  // console.log(`delaying for ${time/1000} seconds before ${nextPhase}`);

  console.log(nextPhase);

  setTimeout(() => {
    // console.log(`time to move to ${coords.x}, ${coords.y}`);
    setPosition(coords);
    if (nextPhase) {
      setNextPhase(nextPhase);
    }
  }, time);
}