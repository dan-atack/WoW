// When either the player's attack throws a baddie, or the baddie's attack throws the player,
// find out if there's an obstacle in the path to the destination and return the closest possible coords:
export const determineObstacle = (distance, direction, attackerCoords, victimCoords, seed) => {
  // console.log(`distance: ${distance}, ${typeof distance}`);
  // console.log(`direction: ${direction}, ${typeof direction}`);
  // console.log(`attacker coords: ${attackerCoords.x}, ${attackerCoords.y}`);
  // console.log(`victim coords: ${victimCoords.x}, ${victimCoords.y}`);
  // Return the location the victim is currently standing in if there is no distance to be thrown:
  if (distance === 0) return victimCoords;
  // For each cardinal direction, make a list of all the squares the victim will cross to travel the distance, in that direction:
  let potentialPositions = [];
  switch (direction) {
    case 'east':
      for (let i = 1; i <= distance; i++) {
        // Only add positions inside the map's boundaries to the PP list:
        if (victimCoords.x + i <= seed.width) {
          potentialPositions.push({
            x: victimCoords.x + i,
            y: victimCoords.y
          })
        }
      }
      break;
    case 'west':
      for (let i = 1; i <= distance; i++) {
        if (victimCoords.x - i > 0) {
          potentialPositions.push({
            x: victimCoords.x - i,
            y: victimCoords.y
          })
        }
      }
      break;
    case 'south':
      for (let i = 1; i <= distance; i++) {
        if (victimCoords.y + i <= seed.height) {
          potentialPositions.push({
            x: victimCoords.x,
            y: victimCoords.y + i
          })
        }
      }
      break;
    case 'north':
      for (let i = 1; i <= distance; i++) {
        if (victimCoords.y - i > 0) {
          potentialPositions.push({
            x: victimCoords.x,
            y: victimCoords.y - i
          })
        }
      }
    default:
      // If the direction given doesn't match, return original coords and display a message (this is an exception):
      if (potentialPositions.length === 0 && distance > 0) {
        // console.log(`Unexpected value given for attack throw direction: ${direction}`);
        return victimCoords;
      }
  }
  // If no valid positions have been generated by this point, the victim is at the edge of the map. Return original coords:
  if (potentialPositions.length === 0) {
    console.log('No valid found for attack throw destination. Returning original coordinates.');
    return victimCoords;
  }
  // Ensure the attacker's own location is not among the potential destinations to prevent rendering errors:
  potentialPositions = potentialPositions.filter(position => position.x != attackerCoords.x && position.y != attackerCoords.y);
  // Next, find which obstacles are potentially in the way of the attack's throw, based on the target's original position:
  let possibleObstacles = [];
  switch (direction) {
    case 'east':
      // Look at all of the obstacles that are to your East (right), then see if you hit any of them:
      possibleObstacles = seed.obstructions.filter((obstacle) => obstacle.x > victimCoords.x);
      // Loop through the potential positions array to see if any of those spaces is obstructed:
      for (const position of potentialPositions) {
        for (const obstacle of possibleObstacles) {
          if (position.x === obstacle.x && position.y === obstacle.y) {
            return { x: position.x - 1, y: victimCoords.y };
          }
        }
      }
      break;
    case 'west':
      possibleObstacles = seed.obstructions.filter((obstacle) => obstacle.x < victimCoords.x);
      for (const position of potentialPositions) {
        for (const obstacle of possibleObstacles) {
          if (position.x === obstacle.x && position.y === obstacle.y) {
            return { x: position.x + 1, y: victimCoords.y };
          }
        }
      }
      break;
    case 'south':
      possibleObstacles = seed.obstructions.filter((obstacle) => obstacle.y > victimCoords.y);
      // Analogue of east case, except that now we get all of the y values that are greater (further south) than you:
      for (const position of potentialPositions) {
        for (const obstacle of possibleObstacles) {
          if (position.x === obstacle.x && position.y === obstacle.y) {
            return { x: victimCoords.x, y: position.y - 1 };
          }
        }
      }
      break;
    case 'north':
      possibleObstacles = seed.obstructions.filter((obstacle) => obstacle.y < victimCoords.y);
      for (const position of potentialPositions) {
        for (const obstacle of possibleObstacles) {
          if (position.x === obstacle.x && position.y === obstacle.y) {
            return { x: victimCoords.x, y: position.y + 1 };
          }
        }
      }
      break;
    default:
      // Default should only occur in the event of some kind of failure in the execution of one of the above cases.
      return victimCoords;
  }
  // If no obstacle is detected, return the farthest destination OR the original coords if there are no potential positions:
  return potentialPositions[potentialPositions.length - 1] || victimCoords;
}

// This is an experimental helper function that will set a one-time timeout that delays the advance to the next combat phase.
// Time = number of milliseconds delay; nextPhase = string name of a combat phase; setNextPhase = dispatcher, passed as a function.
export const advanceCombatSequence = (time, nextPhase, dispatch, setNextPhase) => {
  // console.log(`Initiating ${time / 1000} second countdown to next phase: ${nextPhase}`);
  setTimeout(() => {
    dispatch(setNextPhase(nextPhase));
  }, time);
}

// This function implements a one-time timeout to delay between the start of a MOVEMENT combat phase and its outcome (e.g. between when you click on a tile (or when a baddie 'decides' where to go), and when your character's sprite actually arrives there):
export const advanceCombatWithMovement = async (time, nextPhase, dispatch, setNextPhase, setPosition, coords) => {
  setTimeout(() => {
    setPosition(coords);
    dispatch(setNextPhase(nextPhase));
  }, time);
}